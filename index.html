<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Readable</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=PT+Serif:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            /* Light Theme */
            --bg-body: #F0EFEA;
            --bg-sidebar: #E6E5df;
            --bg-sidebar-hover: #D8D7D1;
            --bg-active-tab: #F0EFEA;
            --text-primary: #383838;
            /* Softer gray */
            --text-secondary: #777777;
            --accent: #383838;
            --border-color: #dcdcdc;
            --editor-bg: #F0EFEA;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);

            --font-ui: 'Inter', sans-serif;
            --font-editor: 'PT Serif', serif;
        }

        [data-theme="dark"] {
            /* Dark Theme */
            --bg-body: #1a1a1a;
            --bg-sidebar: #222222;
            --bg-sidebar-hover: #2a2a2a;
            --bg-active-tab: #1a1a1a;
            --text-primary: #d4d4d4;
            /* Softer white */
            --text-secondary: #999999;
            --accent: #d4d4d4;
            --border-color: #333333;
            --editor-bg: #1a1a1a;
        }

        * {
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-body);
            color: var(--text-primary);
            font-family: var(--font-ui);
            height: 100vh;
            overflow: hidden;
            transition: background 0.3s ease, color 0.3s ease;
        }

        #app {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--bg-sidebar);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            transition: margin-left 0.3s ease;
            /* Transition margin instead of width for smoother perf */
            flex-shrink: 0;
        }

        #app.sidebar-collapsed .sidebar {
            margin-left: -280px;
        }

        .sidebar-header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .app-title {
            font-weight: 600;
            font-size: 1.2rem;
            color: var(--text-primary);
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn:hover {
            background: var(--bg-sidebar-hover);
            color: var(--text-primary);
        }

        .icon-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .tabs-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .tab-item {
            padding: 12px 16px;
            margin-bottom: 4px;
            border-radius: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.95rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .tab-item:hover {
            background: var(--bg-sidebar-hover);
            color: var(--text-primary);
        }

        .tab-item.active {
            background: var(--bg-active-tab);
            color: var(--text-primary);
            font-weight: 500;
            box-shadow: var(--shadow-sm);
        }

        .tab-item.over {
            border: 2px dashed var(--text-secondary);
            opacity: 0.8;
        }

        .tab-content {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .tab-close {
            opacity: 0;
            padding: 4px;
            margin-left: 8px;
            border-radius: 4px;
        }

        .tab-item:hover .tab-close {
            opacity: 1;
        }

        .tab-close:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] .tab-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Editor Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .editor-container {
            flex: 1;
            position: relative;
            background: var(--editor-bg);
        }

        .editor-textarea {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            resize: none;
            padding: 40px 40px;
            /* Uniform padding */
            max-width: 840px;
            /* Optimal reading width */
            margin: 0 auto;
            /* Center content */
            background: transparent;
            color: var(--text-primary);
            font-family: var(--font-editor);
            font-size: 1.35rem;
            line-height: 2.0;
            display: none;
        }

        .editor-textarea.active {
            display: block;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            display: none;
        }

        .empty-state.active {
            display: flex;
            flex-direction: column;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Dropdown Menu */
        .tab-options {
            position: relative;
        }

        .menu-btn {
            opacity: 0;
            padding: 4px;
            margin-left: 8px;
            border-radius: 4px;
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s;
        }

        /* Show on hover OR if active (menu open) */
        .tab-item:hover .menu-btn,
        .menu-btn.active {
            opacity: 1;
        }

        .menu-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            color: var(--text-primary);
        }

        [data-theme="dark"] .menu-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .dropdown-menu {
            position: absolute;
            right: 0;
            top: 100%;
            background: var(--bg-sidebar);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            display: none;
            min-width: 140px;
            overflow: hidden;
            flex-direction: column;
        }

        .dropdown-menu.show {
            display: flex;
        }

        .dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            background: transparent;
            border: none;
            width: 100%;
            text-align: left;
        }

        .dropdown-item:hover {
            background: var(--bg-sidebar-hover);
        }

        .dropdown-item.danger {
            color: #ff4d4f;
        }

        .dropdown-item.danger:hover {
            background: rgba(255, 77, 79, 0.1);
        }

        /* Revision Styles */
        .revision-item {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .revision-header {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }

        .revision-preview {
            font-size: 0.8rem;
            color: var(--text-secondary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-bottom: 8px;
        }

        .revision-actions {
            display: flex;
            gap: 8px;
        }

        .rev-btn {
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: transparent;
            cursor: pointer;
            color: var(--text-primary);
            flex: 1;
        }

        .rev-btn:hover {
            background: var(--bg-sidebar-hover);
        }
    </style>
</head>

<body>

    <div id="app">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="app-title">Readable</div>
                <div style="display: flex; gap: 4px;">
                    <button class="icon-btn" id="new-tab-btn" title="New Note">
                        <svg viewBox="0 0 24 24">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                        </svg>
                    </button>
                    <!-- Sidebar Toggle (Collapse) -->
                    <button class="icon-btn" id="sidebar-toggle-btn" title="Toggle Sidebar">
                        <svg viewBox="0 0 24 24">
                            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
                        </svg>
                    </button>
                </div>
            </div>
            <div class="tabs-list" id="tabs-list">
                <!-- Tab items will be injected here -->
            </div>
            <div
                style="padding: 10px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-start;">
                <button class="icon-btn" id="theme-toggle" title="Toggle Theme">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar Reveal Button (visible when collapsed) -->
            <button id="sidebar-reveal-btn"
                style="position: absolute; top: 10px; left: 10px; z-index: 10; background: transparent; border: none; cursor: pointer; color: var(--text-secondary); opacity: 0; pointer-events: none; transition: opacity 0.2s;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
                </svg>
            </button>

            <div class="editor-container" id="editor-container">
                <div style="position: absolute; top: 10px; right: 20px; z-index: 10; display: flex; gap: 8px;">
                    <button class="icon-btn" id="history-btn" title="Revision History" style="display:none;">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z" />
                        </svg>
                    </button>
                </div>

                <div class="empty-state" id="empty-state">
                    <p>No note selected</p>
                    <p style="font-size: 0.8rem; margin-top: 5px;">Drag & drop text files to import</p>
                    <button
                        style="margin-top: 10px; cursor: pointer; text-decoration: underline; background: none; border: none; color: inherit;"
                        onclick="document.getElementById('new-tab-btn').click()">Create one</button>
                </div>
                <!-- Textareas will be injected here -->
            </div>
        </div>

        <!-- Revisions Modal -->
        <dialog id="revisions-modal"
            style="border: none; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); padding: 20px; max-width: 400px; width: 100%; background: var(--bg-sidebar);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h3 style="margin:0; color:var(--text-primary);">Revision History</h3>
                <button id="close-history-btn" class="icon-btn"><svg viewBox="0 0 24 24">
                        <path
                            d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
                    </svg></button>
            </div>
            <div id="revisions-list" style="max-height: 300px; overflow-y: auto;">
                <!-- List injected here -->
            </div>
        </dialog>
    </div>

    <script>
        // --- CONSTANTS ---
        const DB_NAME = 'ReadableDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'notes';

        // --- STATE ---
        let state = {
            activeTabId: null,
            notes: [],
            db: null
        };

        // --- DOM ELEMENTS ---
        const appEl = document.getElementById('app');
        const tabsListEl = document.getElementById('tabs-list');
        const editorContainerEl = document.getElementById('editor-container');
        const emptyStateEl = document.getElementById('empty-state');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const newTabBtn = document.getElementById('new-tab-btn');
        const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
        const sidebarRevealBtn = document.getElementById('sidebar-reveal-btn');
        const exportBtn = document.getElementById('export-btn');
        const historyBtn = document.getElementById('history-btn');
        const revisionsModal = document.getElementById('revisions-modal');
        const revisionsList = document.getElementById('revisions-list');
        const closeHistoryBtn = document.getElementById('close-history-btn');


        // --- HELPERS ---
        function generateId() {
            return Date.now().toString();
        }

        function formatTime(ms) {
            return new Date(ms).toLocaleString();
        }

        // --- INDEXEDDB ---
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };

                request.onsuccess = (event) => {
                    state.db = event.target.result;
                    resolve(state.db);
                };

                request.onerror = (event) => {
                    console.error('DB Error', event);
                    reject(event);
                };
            });
        }

        async function saveNote(note) {
            if (!state.db) return;
            const tx = state.db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            store.put(note);
            return new Promise(resolve => tx.oncomplete = resolve);
        }

        async function deleteNote(id) {
            if (!state.db) return;
            const tx = state.db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            store.delete(id);
            return new Promise(resolve => tx.oncomplete = resolve);
        }

        async function getAllNotes() {
            if (!state.db) return [];
            return new Promise((resolve) => {
                const tx = state.db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
            });
        }

        // --- MIGRATION ---
        async function checkMigration() {
            const oldData = localStorage.getItem('currentData');
            if (oldData) {
                console.log('Migrating legacy data...');
                const newNote = {
                    id: generateId(),
                    content: oldData,
                    updatedAt: Date.now(),
                    revisions: []
                };
                await saveNote(newNote);
                localStorage.removeItem('currentData');
                localStorage.setItem('migrated_data_backup', oldData);
                return newNote.id;
            }
            return null;
        }

        // --- CORE FUNCTIONS ---
        async function init() {
            await initDB();

            // Check Migration
            const migratedId = await checkMigration();

            // Load Notes
            state.notes = await getAllNotes();

            // Sort by Custom Order if exists, else updatedAt
            const savedOrder = JSON.parse(localStorage.getItem('notes_order') || '[]');
            if (savedOrder.length > 0) {
                const orderMap = new Map(savedOrder.map((id, index) => [id, index]));
                state.notes.sort((a, b) => {
                    const idxA = orderMap.has(a.id) ? orderMap.get(a.id) : Infinity;
                    const idxB = orderMap.has(b.id) ? orderMap.get(b.id) : Infinity;
                    return idxA - idxB; // Standard sort for untracked items is bottom
                });
            } else {
                state.notes.sort((a, b) => b.updatedAt - a.updatedAt);
            }

            // Ensure all notes have revisions array (backward compat)
            state.notes.forEach(n => {
                if (!n.revisions) n.revisions = [];
            });

            // Determine active tab
            if (state.notes.length > 0) {
                state.activeTabId = migratedId || state.notes[0].id;
            } else {
                await createNewNote(false);
            }

            // Drag & Drop Listeners
            document.body.addEventListener('dragover', (e) => {
                e.preventDefault();
                document.body.style.opacity = '0.7';
            });
            document.body.addEventListener('dragleave', () => {
                document.body.style.opacity = '1';
            });
            document.body.addEventListener('drop', async (e) => {
                e.preventDefault();
                document.body.style.opacity = '1';
                if (e.dataTransfer.items) {
                    for (let i = 0; i < e.dataTransfer.items.length; i++) {
                        if (e.dataTransfer.items[i].kind === 'file') {
                            const file = e.dataTransfer.items[i].getAsFile();
                            const content = await file.text();
                            await createNewNote(true, content);
                        }
                    }
                }
            });

            render();
        }

        async function createNewNote(shouldRender = true, initialContent = '') {
            const newNote = {
                id: generateId(),
                content: initialContent,
                updatedAt: Date.now(),
                revisions: []
            };
            state.notes.unshift(newNote); // Add to front
            await saveNote(newNote);
            state.activeTabId = newNote.id;
            if (shouldRender) render();
        }

        // --- UI ---

        // Theme Logic
        const storedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', storedTheme);

        themeToggleBtn.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
        });

        // Sidebar Collapse Logic
        if (sidebarToggleBtn && sidebarRevealBtn) {
            sidebarToggleBtn.addEventListener('click', () => {
                appEl.classList.add('sidebar-collapsed');
                sidebarRevealBtn.style.pointerEvents = 'auto';
                sidebarRevealBtn.style.opacity = '1';
            });
            sidebarRevealBtn.addEventListener('click', () => {
                appEl.classList.remove('sidebar-collapsed');
                sidebarRevealBtn.style.pointerEvents = 'none';
                sidebarRevealBtn.style.opacity = '0';
            });
        }

        // Keyboard Shortcuts (Cmd+S / Ctrl+S)
        document.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                e.preventDefault();
                const note = state.notes.find(n => n.id === state.activeTabId);
                if (note) {
                    addRevision(note);
                    saveNote(note);
                    // Minimal visual feedback
                    const el = document.getElementById(`editor-${note.id}`);
                    if (el) {
                        el.style.transition = 'background-color 0.2s';
                        const originalBg = getComputedStyle(el).backgroundColor;
                        el.style.backgroundColor = 'var(--bg-sidebar-hover)';
                        setTimeout(() => {
                            el.style.backgroundColor = originalBg;
                        }, 200);
                    }
                }
            }
        });

        // Global Click Listener for Dropdowns
        document.addEventListener('click', (e) => {
            // Close all dropdowns if click is outside
            if (!e.target.closest('.dropdown-menu')) {
                closeAllMenus();
            }
        });

        // Close menus on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeAllMenus();
        });

        function closeAllMenus() {
            document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
            document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('menu-active'));
        }

        function showContextMenu(e, noteId) {
            e.preventDefault();
            closeAllMenus();

            const tabItem = document.querySelector(`.tab-item[data-id="${noteId}"]`);
            if (!tabItem) return;

            // Visual feedback
            tabItem.classList.add('menu-active');

            const dropdown = tabItem.querySelector('.dropdown-menu');
            if (dropdown) {
                dropdown.classList.add('show');
            }
        }

        // Event Delegation for Tabs & Menus
        tabsListEl.addEventListener('click', async (e) => {
            // Dropdown Actions
            const actionBtn = e.target.closest('.dropdown-item');
            if (actionBtn) {
                e.stopPropagation();
                const action = actionBtn.dataset.action;
                const noteId = actionBtn.dataset.id;

                closeAllMenus();

                if (action === 'delete') {
                    if (confirm('Delete this note?')) {
                        await deleteNoteAction(noteId);
                    }
                } else if (action === 'export') {
                    const note = state.notes.find(n => n.id === noteId);
                    if (note) exportNote(note);
                }
                return;
            }

            // Tab Selection
            const tabItem = e.target.closest('.tab-item');
            if (tabItem) {
                const id = tabItem.dataset.id;
                setActiveTab(id);
            }
        });

        // Context Menu (Right Click) for Desktop
        tabsListEl.addEventListener('contextmenu', (e) => {
            const tabItem = e.target.closest('.tab-item');
            if (tabItem) {
                const id = tabItem.dataset.id;
                showContextMenu(e, id);
            }
        });

        // Long Press for Mobile
        let longPressTimer;
        const longPressDuration = 500; // ms

        tabsListEl.addEventListener('touchstart', (e) => {
            const tabItem = e.target.closest('.tab-item');
            if (tabItem) {
                longPressTimer = setTimeout(() => {
                    const id = tabItem.dataset.id;
                    showContextMenu(e, id);
                }, longPressDuration);
            }
        }, { passive: false });

        tabsListEl.addEventListener('touchend', () => {
            clearTimeout(longPressTimer);
        });

        tabsListEl.addEventListener('touchmove', () => {
            clearTimeout(longPressTimer);
        });

        newTabBtn.addEventListener('click', () => {
            createNewNote();
        });

        // Global Export (Hidden if unused, but logic kept for helper)
        function exportNote(note) {
            const blob = new Blob([note.content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${getTitle(note.content)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Revision History Logic
        if (historyBtn && revisionsModal) {
            historyBtn.addEventListener('click', () => {
                const note = state.notes.find(n => n.id === state.activeTabId);
                if (!note) return;

                revisionsList.innerHTML = '';
                if (!note.revisions || note.revisions.length === 0) {
                    revisionsList.innerHTML = '<p style="color:var(--text-secondary); text-align:center; padding: 20px;">No history yet.</p>';
                } else {
                    // Show latest first
                    [...note.revisions].reverse().forEach(rev => {
                        const div = document.createElement('div');
                        div.className = 'revision-item';
                        div.innerHTML = `
                           <div class="revision-header">
                                <span>${formatTime(rev.timestamp)}</span>
                           </div>
                           <div class="revision-preview">${rev.content.substring(0, 60) || '(Empty)'}</div>
                           <div class="revision-actions">
                                <button class="rev-btn restore-original">Restore Here</button>
                                <button class="rev-btn restore-new">New Note</button>
                           </div>
                       `;

                        // Event Listeners for buttons
                        const restoreOriginalBtn = div.querySelector('.restore-original');
                        const restoreNewBtn = div.querySelector('.restore-new');

                        restoreOriginalBtn.onclick = async () => {
                            if (confirm(`Restore to this version? Current content will be saved as a revision.`)) {
                                addRevision(note);
                                note.content = rev.content;
                                note.updatedAt = Date.now();
                                await saveNote(note);
                                // Update UI
                                const textarea = document.getElementById(`editor-${note.id}`);
                                if (textarea) textarea.value = note.content;
                                render();
                                revisionsModal.close();
                            }
                        };

                        restoreNewBtn.onclick = async () => {
                            await createNewNote(true, rev.content);
                            revisionsModal.close();
                        };

                        revisionsList.appendChild(div);
                    });
                }
                revisionsModal.showModal();
            });

            closeHistoryBtn.addEventListener('click', () => {
                revisionsModal.close();
            });
        }

        async function setActiveTab(id) {
            state.activeTabId = id;
            render();
            // Focus the active textarea
            setTimeout(() => {
                const el = document.getElementById(`editor-${id}`);
                if (el) el.focus();
            }, 0);
        }

        async function deleteNoteAction(id) {
            await deleteNote(id);
            state.notes = state.notes.filter(n => n.id !== id);

            if (state.activeTabId === id) {
                state.activeTabId = state.notes.length > 0 ? state.notes[0].id : null;
            }
            render();
        }

        function getTitle(content) {
            if (!content || !content.trim()) return 'New Note';
            const firstLine = content.split('\n')[0].trim();
            if (!firstLine) return 'New Note';
            return firstLine.substring(0, 30) + (firstLine.length > 30 ? '...' : '');
        }

        function render() {
            // 1. Render Tabs
            tabsListEl.innerHTML = '';

            state.notes.forEach(note => {
                const isActive = note.id === state.activeTabId;
                const div = document.createElement('div');
                div.className = `tab-item ${isActive ? 'active' : ''}`;
                div.dataset.id = note.id;
                div.draggable = true;

                // Grip Icon (Vertical)
                const gripIcon = `<svg viewBox="0 0 24 24" style="width:16px;height:16px;color:var(--text-secondary);"><path d="M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>`;

                // Use drag handle for the grip
                div.innerHTML = `
                    <div class="tab-options" style="margin-right: 8px;">
                        <button class="menu-btn drag-handle" title="Menu / Drag to Reorder" style="cursor: grab;">${gripIcon}</button>
                        <div class="dropdown-menu" style="right: auto; left: 0;">
                            <button class="dropdown-item" data-action="export" data-id="${note.id}">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                                Export .txt
                            </button>
                            <button class="dropdown-item danger" data-action="delete" data-id="${note.id}">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                                Delete
                            </button>
                        </div>
                    </div>
                    <div class="tab-content">${getTitle(note.content) || 'New Note'}</div>
                `;
                tabsListEl.appendChild(div);
            });

            // Enabling Drag & Drop Reordering
            enableDragAndDrop();

            // 2. Sync Editors
            const existingEditors = new Set(
                Array.from(editorContainerEl.querySelectorAll('.editor-textarea'))
                    .map(el => el.dataset.id)
            );

            // ... (Rest of render) ...

            // Register Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('SW registered', reg))
                    .catch(err => console.error('SW registration failed', err));
            }

            // Add new ones
            state.notes.forEach(note => {
                if (!existingEditors.has(note.id)) {
                    createEditorElement(note);
                }
            });

            // Remove deleted ones
            existingEditors.forEach(id => {
                if (!state.notes.find(n => n.id === id)) {
                    const el = document.getElementById(`editor-${id}`);
                    if (el) el.remove();
                }
            });

            // Toggle Visibility
            const allEditors = editorContainerEl.querySelectorAll('.editor-textarea');
            allEditors.forEach(el => {
                if (el.dataset.id === state.activeTabId) {
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
            });

            // Empty State
            if (state.notes.length === 0) {
                emptyStateEl.classList.add('active');
                if (exportBtn) exportBtn.style.display = 'none';
                if (historyBtn) historyBtn.style.display = 'none';
            } else {
                emptyStateEl.classList.remove('active');
                if (exportBtn) exportBtn.style.display = 'flex';
                if (historyBtn) historyBtn.style.display = 'flex';
            }
        }

        let dragSrcEl = null;

        function enableDragAndDrop() {
            const items = document.querySelectorAll('.tab-item');
            items.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragenter', handleDragEnter);
                item.addEventListener('dragleave', handleDragLeave);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
            });
        }

        function handleDragStart(e) {
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            this.style.opacity = '0.4';
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            this.classList.add('over');
        }

        function handleDragLeave(e) {
            this.classList.remove('over');
        }

        async function handleDrop(e) {
            // e.stopPropagation(); // Stops some browsers from redirecting.
            e.preventDefault();

            if (dragSrcEl !== this) {
                // Reorder state.notes
                const fromId = dragSrcEl.dataset.id;
                const toId = this.dataset.id;

                const fromIndex = state.notes.findIndex(n => n.id === fromId);
                const toIndex = state.notes.findIndex(n => n.id === toId);

                if (fromIndex > -1 && toIndex > -1) {
                    // Move in array
                    const [movedNote] = state.notes.splice(fromIndex, 1);
                    state.notes.splice(toIndex, 0, movedNote);

                    // Persist Order
                    const orderIds = state.notes.map(n => n.id);
                    localStorage.setItem('notes_order', JSON.stringify(orderIds));

                    render();
                }
            }
            return false;
        }

        function handleDragEnd(e) {
            this.style.opacity = '1';
            document.querySelectorAll('.tab-item').forEach(item => {
                item.classList.remove('over');
            });
            dragSrcEl = null;
        }

        function addRevision(note) {
            if (!note.revisions) note.revisions = [];
            note.revisions.push({
                timestamp: Date.now(),
                content: note.content
            });
            // Keep last 20
            if (note.revisions.length > 20) {
                note.revisions.shift();
            }
        }

        function createEditorElement(note) {
            const textarea = document.createElement('textarea');
            textarea.className = 'editor-textarea';
            textarea.id = `editor-${note.id}`;
            textarea.dataset.id = note.id;
            textarea.placeholder = "Start typing...";
            textarea.value = note.content;
            textarea.setAttribute('spellcheck', 'false');

            // Event Listener for Input
            textarea.addEventListener('input', (e) => {
                const content = e.target.value;
                const id = note.id;

                // Update State
                const noteObj = state.notes.find(n => n.id === id);
                if (noteObj) {
                    noteObj.content = content;
                    noteObj.updatedAt = Date.now();
                }

                // Update Tab Title (Optimistic)
                const tabEl = tabsListEl.querySelector(`.tab-item[data-id="${id}"] .tab-content`);
                if (tabEl) {
                    tabEl.textContent = getTitle(content);
                }

                // Debounce Save to DB
                saveNoteDebounced(noteObj);
            });

            editorContainerEl.appendChild(textarea);
        }

        // Debounce Utility
        let saveTimeouts = {};
        function saveNoteDebounced(note) {
            if (saveTimeouts[note.id]) clearTimeout(saveTimeouts[note.id]);
            saveTimeouts[note.id] = setTimeout(() => {
                // Save revision logic
                if (!note.revisions) note.revisions = [];
                const lastRev = note.revisions[note.revisions.length - 1];
                const now = Date.now();

                // Save revision if > 5 minutes have passed since last revision or no revisions yet
                if (!lastRev || (now - lastRev.timestamp > 300000)) {
                    addRevision(note);
                }

                saveNote(note);
            }, 1000); // 1s debounce
        }

        console.log("App Initialized");
        init();
    </script>
</body>

</html>